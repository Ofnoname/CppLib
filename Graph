#ifndef GRAPH_H
#define GRAPH_H

template <unsigned N, unsigned M = N*(N-1)/2>
class Graph;

template <unsigned N, unsigned M>
class Graph
{
	private:
		using vertex = unsigned;

		struct edge {
			int w;
			vertex u, v, uv;
		}edge_set[M];

		std::vector<edge*> out_edge[N];

	public:
		void add_edge(vertex u, vertex v, int w = 1, bool undirect = false) {
			static edge* tc = edge_set;
			*(tc++) = edge{w, u, v, u^v};

			out_edge[u].push_back(tc);
			if (undirect) out_edge[v].push_back(tc);
		}

		void Dijistra(vertex start, int *ans);
};

template <unsigned N, unsigned M>
void Graph<N, M>::Dijistra(vertex start, int *dis) {
	struct cmp{
		bool operator()(const int &A, const int &B){
		return dis[A] < dis[B];
		}
	}
	std::priority_queue <int, vector<int>, cmp> Q;
	std::bitset <N> vis, inq;

	dis[start] = 0;
	Q.emplace(start);
	while (Q.size()) {
		vertex u = Q.top(); Q.pop();

		for (auto e: out_edge[u]) {
			vertex v = e->uv ^ u;
			if (!vis[v] || dis[v]<dis[u]+e->w) {
				vis[v] = 1;
				dis[v] = dis[u] + e->w;

				if (!inq[v]) {
					inq[v] = 1;
					Q.emplace(v);
				}
			}
		}
	}
}

#endif